// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package storage

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createMedicine = `-- name: CreateMedicine :one

INSERT INTO medicines
    (
        name,
        category,
        description,
        price,
        company,
        status
    )
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING
    id, 
    name,
    category,
    description,
    price,
    company,
    status,
    created_at,
    updated_at
`

type CreateMedicineParams struct {
	Name        string
	Category    MedicineCategory
	Description string
	Price       string
	Company     string
	Status      MedicineStatus
}

type CreateMedicineRow struct {
	ID          uuid.UUID
	Name        string
	Category    MedicineCategory
	Description string
	Price       string
	Company     string
	Status      MedicineStatus
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

// -------------- Medicine CRUD ----------------
func (q *Queries) CreateMedicine(ctx context.Context, arg CreateMedicineParams) (CreateMedicineRow, error) {
	row := q.db.QueryRowContext(ctx, createMedicine,
		arg.Name,
		arg.Category,
		arg.Description,
		arg.Price,
		arg.Company,
		arg.Status,
	)
	var i CreateMedicineRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Category,
		&i.Description,
		&i.Price,
		&i.Company,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMedicineCategory = `-- name: CreateMedicineCategory :one

INSERT INTO medicines_category
    (
        name,
        description
    )
VALUES ($1, $2)
RETURNING
    id,
    name,
    description,
    created_at,
    updated_at
`

type CreateMedicineCategoryParams struct {
	Name        MedicineCategory
	Description string
}

type CreateMedicineCategoryRow struct {
	ID          uuid.UUID
	Name        MedicineCategory
	Description string
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

// -------------- Medicine Category CRUD ----------------
func (q *Queries) CreateMedicineCategory(ctx context.Context, arg CreateMedicineCategoryParams) (CreateMedicineCategoryRow, error) {
	row := q.db.QueryRowContext(ctx, createMedicineCategory, arg.Name, arg.Description)
	var i CreateMedicineCategoryRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMedicine = `-- name: DeleteMedicine :exec
UPDATE medicines
SET deleted_at = $2
WHERE id = $1
`

type DeleteMedicineParams struct {
	ID        uuid.UUID
	DeletedAt sql.NullTime
}

func (q *Queries) DeleteMedicine(ctx context.Context, arg DeleteMedicineParams) error {
	_, err := q.db.ExecContext(ctx, deleteMedicine, arg.ID, arg.DeletedAt)
	return err
}

const deleteMedicineCategory = `-- name: DeleteMedicineCategory :exec
UPDATE medicines_category
SET deleted_at = $2
WHERE id = $1
`

type DeleteMedicineCategoryParams struct {
	ID        uuid.UUID
	DeletedAt sql.NullTime
}

func (q *Queries) DeleteMedicineCategory(ctx context.Context, arg DeleteMedicineCategoryParams) error {
	_, err := q.db.ExecContext(ctx, deleteMedicineCategory, arg.ID, arg.DeletedAt)
	return err
}

const getMedicineById = `-- name: GetMedicineById :one
SELECT 
    id,
    name,
    category,
    company,
    status,
    price,
    created_at,
    updated_at
FROM 
    medicines
WHERE id=$1
    AND deleted_at IS NULL
`

type GetMedicineByIdRow struct {
	ID        uuid.UUID
	Name      string
	Category  MedicineCategory
	Company   string
	Status    MedicineStatus
	Price     string
	CreatedAt sql.NullTime
	UpdatedAt sql.NullTime
}

func (q *Queries) GetMedicineById(ctx context.Context, id uuid.UUID) (GetMedicineByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getMedicineById, id)
	var i GetMedicineByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Category,
		&i.Company,
		&i.Status,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMedicineCategoryById = `-- name: GetMedicineCategoryById :one
SELECT 
    id,
    name,
    description,
    created_at,
    updated_at
FROM 
    medicines_category
WHERE id=$1
`

type GetMedicineCategoryByIdRow struct {
	ID          uuid.UUID
	Name        MedicineCategory
	Description string
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) GetMedicineCategoryById(ctx context.Context, id uuid.UUID) (GetMedicineCategoryByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getMedicineCategoryById, id)
	var i GetMedicineCategoryByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listMedicineCategories = `-- name: ListMedicineCategories :many
SELECT
    id,
    name,
    description,
    created_at,
    updated_at,
    COUNT(*) OVER() AS total_count
FROM 
    medicines_category
WHERE deleted_at IS NULL
    AND (
        $1::search IS NULL 
        OR LOWER(name) LIKE LOWER(CONCAT('%', $1::search, '%'))
    )
ORDER BY
    created_at DESC
LIMIT $2 
OFFSET ($3 - 1) * $2
`

type ListMedicineCategoriesParams struct {
	Column1 interface{}
	Limit   int32
	Column3 interface{}
}

type ListMedicineCategoriesRow struct {
	ID          uuid.UUID
	Name        MedicineCategory
	Description string
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	TotalCount  int64
}

func (q *Queries) ListMedicineCategories(ctx context.Context, arg ListMedicineCategoriesParams) ([]ListMedicineCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, listMedicineCategories, arg.Column1, arg.Limit, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMedicineCategoriesRow
	for rows.Next() {
		var i ListMedicineCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMedicines = `-- name: ListMedicines :many
SELECT
    id,
    name,
    category,
    company,
    status,
    price,
    created_at,
    updated_at,
    COUNT(*) OVER() AS total_count  -- total count filtering boyicha
FROM
    medicines
WHERE deleted_at IS NULL
    AND (
        $1::search IS NULL  -- :search - frontenddan kelgan parametr. NULL bolsa, barcha datalarni qaytaradi. Agar bosh bolmasa name, category, company ustunlarida qidirishni boshlaydi.
        OR LOWER(name) LIKE LOWER(CONCAT('%', $1::search, '%')) --LOWER - barcha harflarni kichkina qilib oladi. 
        OR LOWER(category) LIKE LOWER(CONCAT('%', $1::search, '%')) -- CONCAT('%', :search, '%') - example: %aspirin% qilib qidiradi, yani matn ichida qayerdan bolmasin topadi.
        OR LOWER(company) LIKE LOWER(CONCAT('%', $1::search, '%'))
    )
    AND ($2::status IS NULL OR status = $2::status) -- agar stus NULL bolsa barcha yozuvlar olinadi, bolmasa taqqoslaydi.
ORDER BY
    created_at DESC -- yaratilgan sana boyicha teskari tartibda chiqaradi, natijada eng yangilari birinchi chiqadi.
LIMIT $3 -- faqat n ta row olinadi
OFFSET ($4 - 1) * $3
`

type ListMedicinesParams struct {
	Column1 interface{}
	Column2 interface{}
	Limit   int32
	Column4 interface{}
}

type ListMedicinesRow struct {
	ID         uuid.UUID
	Name       string
	Category   MedicineCategory
	Company    string
	Status     MedicineStatus
	Price      string
	CreatedAt  sql.NullTime
	UpdatedAt  sql.NullTime
	TotalCount int64
}

func (q *Queries) ListMedicines(ctx context.Context, arg ListMedicinesParams) ([]ListMedicinesRow, error) {
	rows, err := q.db.QueryContext(ctx, listMedicines,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMedicinesRow
	for rows.Next() {
		var i ListMedicinesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Company,
			&i.Status,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMedicine = `-- name: UpdateMedicine :one

UPDATE medicines
SET
    name = $2,
    category = $3,
    description = $4,
    price = $5,
    company = $6,
    status = $7,
    updated_at = $8
WHERE id = $1
    AND deleted_at IS NULL
RETURNING
    id, 
    name,
    category,
    description,
    price,
    company,
    status,
    created_at,
    updated_at
`

type UpdateMedicineParams struct {
	ID          uuid.UUID
	Name        string
	Category    MedicineCategory
	Description string
	Price       string
	Company     string
	Status      MedicineStatus
	UpdatedAt   sql.NullTime
}

type UpdateMedicineRow struct {
	ID          uuid.UUID
	Name        string
	Category    MedicineCategory
	Description string
	Price       string
	Company     string
	Status      MedicineStatus
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

// m ta row oâ€˜tkazib, keyingilarini oladi
func (q *Queries) UpdateMedicine(ctx context.Context, arg UpdateMedicineParams) (UpdateMedicineRow, error) {
	row := q.db.QueryRowContext(ctx, updateMedicine,
		arg.ID,
		arg.Name,
		arg.Category,
		arg.Description,
		arg.Price,
		arg.Company,
		arg.Status,
		arg.UpdatedAt,
	)
	var i UpdateMedicineRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Category,
		&i.Description,
		&i.Price,
		&i.Company,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMedicineCategory = `-- name: UpdateMedicineCategory :one
UPDATE medicines_category
SET 
    name = $2,
    description = $3,
    updated_at = $4
WHERE id=$1
    AND deleted_at IS NULL
RETURNING
    id,
    name,
    description,
    created_at,
    updated_at
`

type UpdateMedicineCategoryParams struct {
	ID          uuid.UUID
	Name        MedicineCategory
	Description string
	UpdatedAt   sql.NullTime
}

type UpdateMedicineCategoryRow struct {
	ID          uuid.UUID
	Name        MedicineCategory
	Description string
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) UpdateMedicineCategory(ctx context.Context, arg UpdateMedicineCategoryParams) (UpdateMedicineCategoryRow, error) {
	row := q.db.QueryRowContext(ctx, updateMedicineCategory,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.UpdatedAt,
	)
	var i UpdateMedicineCategoryRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

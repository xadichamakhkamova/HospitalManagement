// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package storage

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createPatient = `-- name: CreatePatient :one

INSERT INTO patients
    (
        full_name, 
        email,
        password,
        address,
        phone_number,
        gender,
        birth_date,
        blood_group
    )
VALUES($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING
    id,
    full_name, 
    email,
    password,
    address,
    phone_number,
    gender,
    birth_date,
    blood_group,
    created_at,
    updated_at
`

type CreatePatientParams struct {
	FullName    string
	Email       string
	Password    string
	Address     string
	PhoneNumber string
	Gender      GenderType
	BirthDate   time.Time
	BloodGroup  BloodType
}

type CreatePatientRow struct {
	ID          uuid.UUID
	FullName    string
	Email       string
	Password    string
	Address     string
	PhoneNumber string
	Gender      GenderType
	BirthDate   time.Time
	BloodGroup  BloodType
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

// -------------- Patient CRUD ----------------
func (q *Queries) CreatePatient(ctx context.Context, arg CreatePatientParams) (CreatePatientRow, error) {
	row := q.db.QueryRowContext(ctx, createPatient,
		arg.FullName,
		arg.Email,
		arg.Password,
		arg.Address,
		arg.PhoneNumber,
		arg.Gender,
		arg.BirthDate,
		arg.BloodGroup,
	)
	var i CreatePatientRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Address,
		&i.PhoneNumber,
		&i.Gender,
		&i.BirthDate,
		&i.BloodGroup,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePatient = `-- name: DeletePatient :exec
UPDATE patients
SET deleted_at = $2
WHERE id = $1
`

type DeletePatientParams struct {
	ID        uuid.UUID
	DeletedAt sql.NullTime
}

func (q *Queries) DeletePatient(ctx context.Context, arg DeletePatientParams) error {
	_, err := q.db.ExecContext(ctx, deletePatient, arg.ID, arg.DeletedAt)
	return err
}

const getPatientById = `-- name: GetPatientById :one
SELECT 
    id,
    full_name, 
    email,
    password,
    address,
    phone_number,
    gender,
    birth_date,
    blood_group,
    created_at,
    updated_at 
FROM 
    patients
WHERE id = $1 
    AND deleted_at IS NULL
`

type GetPatientByIdRow struct {
	ID          uuid.UUID
	FullName    string
	Email       string
	Password    string
	Address     string
	PhoneNumber string
	Gender      GenderType
	BirthDate   time.Time
	BloodGroup  BloodType
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) GetPatientById(ctx context.Context, id uuid.UUID) (GetPatientByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getPatientById, id)
	var i GetPatientByIdRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Address,
		&i.PhoneNumber,
		&i.Gender,
		&i.BirthDate,
		&i.BloodGroup,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPatients = `-- name: ListPatients :many
SELECT
    id,
    full_name, 
    email,
    password,
    address,
    phone_number,
    gender,
    birth_date,
    blood_group,
    created_at,
    updated_at,
    COUNT(*) OVER() AS total_count
FROM 
    patients
WHERE deleted_at IS NULL
    AND (
        $1::text=''
        OR LOWER(full_name) LIKE LOWER(CONCAT('%', $1::text, '%')) 
        OR LOWER(email) LIKE LOWER(CONCAT('%', $1::text, '%')) 
        OR LOWER(gender) LIKE LOWER(CONCAT('%', $1::text, '%'))
    )
ORDER BY 
    created_at DESC 
LIMIT $2
OFFSET ($3 - 1) * $2
`

type ListPatientsParams struct {
	Column1 string
	Limit   int32
	Column3 interface{}
}

type ListPatientsRow struct {
	ID          uuid.UUID
	FullName    string
	Email       string
	Password    string
	Address     string
	PhoneNumber string
	Gender      GenderType
	BirthDate   time.Time
	BloodGroup  BloodType
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	TotalCount  int64
}

func (q *Queries) ListPatients(ctx context.Context, arg ListPatientsParams) ([]ListPatientsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPatients, arg.Column1, arg.Limit, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPatientsRow
	for rows.Next() {
		var i ListPatientsRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Email,
			&i.Password,
			&i.Address,
			&i.PhoneNumber,
			&i.Gender,
			&i.BirthDate,
			&i.BloodGroup,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePatient = `-- name: UpdatePatient :one
UPDATE patients
SET 
    full_name = $2, 
    email = $3,
    password = $4,
    address = $5,
    phone_number = $6,
    gender = $7,
    birth_date = $8,
    blood_group = $9,
    updated_at = $10 
WHERE id = $1
    AND deleted_at IS NULL
RETURNING
    id,
    full_name, 
    email,
    password,
    address,
    phone_number,
    gender,
    birth_date,
    blood_group,
    created_at,
    updated_at
`

type UpdatePatientParams struct {
	ID          uuid.UUID
	FullName    string
	Email       string
	Password    string
	Address     string
	PhoneNumber string
	Gender      GenderType
	BirthDate   time.Time
	BloodGroup  BloodType
	UpdatedAt   sql.NullTime
}

type UpdatePatientRow struct {
	ID          uuid.UUID
	FullName    string
	Email       string
	Password    string
	Address     string
	PhoneNumber string
	Gender      GenderType
	BirthDate   time.Time
	BloodGroup  BloodType
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) UpdatePatient(ctx context.Context, arg UpdatePatientParams) (UpdatePatientRow, error) {
	row := q.db.QueryRowContext(ctx, updatePatient,
		arg.ID,
		arg.FullName,
		arg.Email,
		arg.Password,
		arg.Address,
		arg.PhoneNumber,
		arg.Gender,
		arg.BirthDate,
		arg.BloodGroup,
		arg.UpdatedAt,
	)
	var i UpdatePatientRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Address,
		&i.PhoneNumber,
		&i.Gender,
		&i.BirthDate,
		&i.BloodGroup,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

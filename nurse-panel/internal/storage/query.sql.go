// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package storage

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const assignPatientToBed = `-- name: AssignPatientToBed :one

INSERT INTO bed_management 
    (
        bed_id, 
        patient_id, 
        status
    )
VALUES ($1, $2, 'BED_OCCUPIED')
RETURNING 
    id, 
    bed_id, 
    patient_id, 
    status, 
    assigned_at, 
    updated_at
`

type AssignPatientToBedParams struct {
	BedID     uuid.UUID
	PatientID uuid.UUID
}

// -------------- Bed Management----------------
func (q *Queries) AssignPatientToBed(ctx context.Context, arg AssignPatientToBedParams) (BedManagement, error) {
	row := q.db.QueryRowContext(ctx, assignPatientToBed, arg.BedID, arg.PatientID)
	var i BedManagement
	err := row.Scan(
		&i.ID,
		&i.BedID,
		&i.PatientID,
		&i.Status,
		&i.AssignedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDonor = `-- name: CreateDonor :one

INSERT INTO donors
    (
        full_name, 
        email,
        password,
        address,
        phone_number,
        gender,
        birth_date,
        blood_group,
        weight,
        health_condition
    )
VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING
    id,
    full_name, 
    email,
    password,
    address,
    phone_number,
    gender,
    birth_date,
    blood_group,
    weight,
    health_condition,
    created_at,
    updated_at
`

type CreateDonorParams struct {
	FullName        string
	Email           string
	Password        string
	Address         string
	PhoneNumber     string
	Gender          interface{}
	BirthDate       time.Time
	BloodGroup      interface{}
	Weight          int16
	HealthCondition interface{}
}

type CreateDonorRow struct {
	ID              uuid.UUID
	FullName        string
	Email           string
	Password        string
	Address         string
	PhoneNumber     string
	Gender          interface{}
	BirthDate       time.Time
	BloodGroup      interface{}
	Weight          int16
	HealthCondition interface{}
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
}

// -------------- Donor CRUD ----------------
func (q *Queries) CreateDonor(ctx context.Context, arg CreateDonorParams) (CreateDonorRow, error) {
	row := q.db.QueryRowContext(ctx, createDonor,
		arg.FullName,
		arg.Email,
		arg.Password,
		arg.Address,
		arg.PhoneNumber,
		arg.Gender,
		arg.BirthDate,
		arg.BloodGroup,
		arg.Weight,
		arg.HealthCondition,
	)
	var i CreateDonorRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Address,
		&i.PhoneNumber,
		&i.Gender,
		&i.BirthDate,
		&i.BloodGroup,
		&i.Weight,
		&i.HealthCondition,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDonor = `-- name: DeleteDonor :exec
UPDATE donors
SET deleted_at = $2
WHERE id = $1
`

type DeleteDonorParams struct {
	ID        uuid.UUID
	DeletedAt sql.NullTime
}

func (q *Queries) DeleteDonor(ctx context.Context, arg DeleteDonorParams) error {
	_, err := q.db.ExecContext(ctx, deleteDonor, arg.ID, arg.DeletedAt)
	return err
}

const getBedById = `-- name: GetBedById :one
SELECT 
    id,
    bed_id,
    patient_id,
    status,
    assigned_at,
    updated_at
FROM bed_management
WHERE bed_id = $1
ORDER BY 
    updated_at DESC
LIMIT 1
`

func (q *Queries) GetBedById(ctx context.Context, bedID uuid.UUID) (BedManagement, error) {
	row := q.db.QueryRowContext(ctx, getBedById, bedID)
	var i BedManagement
	err := row.Scan(
		&i.ID,
		&i.BedID,
		&i.PatientID,
		&i.Status,
		&i.AssignedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDonorById = `-- name: GetDonorById :one
SELECT 
    id,
    full_name, 
    email,
    password,
    address,
    phone_number,
    gender,
    birth_date,
    blood_group,
    last_donation,
    donation_count,
    (weight >= 50 AND health_condition = 'HEALTHY') AS is_eligible,
    last_checkup_date,
    weight,
    health_condition,
    donation_location,
    created_at,
    updated_at 
FROM 
    donors
WHERE id=$1 
    AND deleted_at IS NULL
`

type GetDonorByIdRow struct {
	ID               uuid.UUID
	FullName         string
	Email            string
	Password         string
	Address          string
	PhoneNumber      string
	Gender           interface{}
	BirthDate        time.Time
	BloodGroup       interface{}
	LastDonation     sql.NullTime
	DonationCount    sql.NullInt32
	IsEligible       sql.NullBool
	LastCheckupDate  sql.NullTime
	Weight           int16
	HealthCondition  interface{}
	DonationLocation sql.NullString
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
}

func (q *Queries) GetDonorById(ctx context.Context, id uuid.UUID) (GetDonorByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getDonorById, id)
	var i GetDonorByIdRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Address,
		&i.PhoneNumber,
		&i.Gender,
		&i.BirthDate,
		&i.BloodGroup,
		&i.LastDonation,
		&i.DonationCount,
		&i.IsEligible,
		&i.LastCheckupDate,
		&i.Weight,
		&i.HealthCondition,
		&i.DonationLocation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listBeds = `-- name: ListBeds :many
SELECT 
    id,
    bed_id,
    patient_id,
    status,
    assigned_at,
    updated_at,
    COUNT(*) OVER() AS total_count
FROM 
    bed_management
WHERE 
    (  
        $1::search  IS NULL
        OR LOWER(status) LIKE LOWER(CONCAT('%', $1::search , '%'))
    ) 
ORDER BY 
    updated_at DESC 
LIMIT $2
OFFSET ($3 - 1) * $2
`

type ListBedsParams struct {
	Column1 interface{}
	Limit   int32
	Column3 interface{}
}

type ListBedsRow struct {
	ID         uuid.UUID
	BedID      uuid.UUID
	PatientID  uuid.UUID
	Status     interface{}
	AssignedAt sql.NullTime
	UpdatedAt  sql.NullTime
	TotalCount int64
}

func (q *Queries) ListBeds(ctx context.Context, arg ListBedsParams) ([]ListBedsRow, error) {
	rows, err := q.db.QueryContext(ctx, listBeds, arg.Column1, arg.Limit, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBedsRow
	for rows.Next() {
		var i ListBedsRow
		if err := rows.Scan(
			&i.ID,
			&i.BedID,
			&i.PatientID,
			&i.Status,
			&i.AssignedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDonors = `-- name: ListDonors :many
SELECT 
    id,
    full_name, 
    email,
    password,
    address,
    phone_number,
    gender,
    birth_date,
    blood_group,
    last_donation,
    donation_count,
    (weight >= 50 AND health_condition = 'HEALTHY') AS is_eligible,
    last_checkup_date,
    weight,
    health_condition,
    donation_location,
    created_at,
    updated_at,
    COUNT(*) OVER() AS total_count
FROM 
    donors 
WHERE 
    deleted_at IS NULL
    AND (
        $1::search  IS NULL 
        OR LOWER(full_name) LIKE LOWER(CONCAT('%', $1::search , '%')) 
        OR LOWER(email) LIKE LOWER(CONCAT('%', $1::search , '%')) 
        OR LOWER(gender) LIKE LOWER(CONCAT('%', $1::search , '%')) 
        OR LOWER(blood_group) LIKE LOWER(CONCAT('%', $1::search , '%'))
    )
    AND (
        $2::only_eligible = FALSE 
        OR (weight >= 50 AND health_condition = 'HEALTHY') -- if equal to DEFAULT
    )
ORDER BY 
    created_at DESC 
LIMIT $3
OFFSET ($4 - 1) * $3
`

type ListDonorsParams struct {
	Column1 interface{}
	Column2 interface{}
	Limit   int32
	Column4 interface{}
}

type ListDonorsRow struct {
	ID               uuid.UUID
	FullName         string
	Email            string
	Password         string
	Address          string
	PhoneNumber      string
	Gender           interface{}
	BirthDate        time.Time
	BloodGroup       interface{}
	LastDonation     sql.NullTime
	DonationCount    sql.NullInt32
	IsEligible       sql.NullBool
	LastCheckupDate  sql.NullTime
	Weight           int16
	HealthCondition  interface{}
	DonationLocation sql.NullString
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	TotalCount       int64
}

func (q *Queries) ListDonors(ctx context.Context, arg ListDonorsParams) ([]ListDonorsRow, error) {
	rows, err := q.db.QueryContext(ctx, listDonors,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDonorsRow
	for rows.Next() {
		var i ListDonorsRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Email,
			&i.Password,
			&i.Address,
			&i.PhoneNumber,
			&i.Gender,
			&i.BirthDate,
			&i.BloodGroup,
			&i.LastDonation,
			&i.DonationCount,
			&i.IsEligible,
			&i.LastCheckupDate,
			&i.Weight,
			&i.HealthCondition,
			&i.DonationLocation,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerCheckup = `-- name: RegisterCheckup :one
UPDATE donors
SET 
    last_checkup_date = NOW(),
    updated_at = NOW()
WHERE id = $1
    AND deleted_at IS NULL
RETURNING 
    last_checkup_date,
    (weight >= 50 AND health_condition = 'HEALTHY') AS is_eligible
`

type RegisterCheckupRow struct {
	LastCheckupDate sql.NullTime
	IsEligible      sql.NullBool
}

func (q *Queries) RegisterCheckup(ctx context.Context, id uuid.UUID) (RegisterCheckupRow, error) {
	row := q.db.QueryRowContext(ctx, registerCheckup, id)
	var i RegisterCheckupRow
	err := row.Scan(&i.LastCheckupDate, &i.IsEligible)
	return i, err
}

const registerDonation = `-- name: RegisterDonation :one
UPDATE donors
SET 
    last_donation = NOW(),
    donation_count = donation_count + 1,
    donation_location = $2,
    updated_at = NOW()
WHERE id = $1
    AND deleted_at IS NULL
RETURNING 
    last_donation,
    donation_count,
    (weight >= 50 AND health_condition = 'HEALTHY') AS is_eligible
`

type RegisterDonationParams struct {
	ID               uuid.UUID
	DonationLocation sql.NullString
}

type RegisterDonationRow struct {
	LastDonation  sql.NullTime
	DonationCount sql.NullInt32
	IsEligible    sql.NullBool
}

func (q *Queries) RegisterDonation(ctx context.Context, arg RegisterDonationParams) (RegisterDonationRow, error) {
	row := q.db.QueryRowContext(ctx, registerDonation, arg.ID, arg.DonationLocation)
	var i RegisterDonationRow
	err := row.Scan(&i.LastDonation, &i.DonationCount, &i.IsEligible)
	return i, err
}

const releaseBed = `-- name: ReleaseBed :one
UPDATE bed_management
SET 
    status = 'BED_AVAILABLE', 
    updated_at = NOW()
WHERE bed_id = $1 
    AND status = 'BED_OCCUPIED'
RETURNING 
    id, 
    bed_id, 
    patient_id, 
    status, 
    assigned_at, 
    updated_at
`

func (q *Queries) ReleaseBed(ctx context.Context, bedID uuid.UUID) (BedManagement, error) {
	row := q.db.QueryRowContext(ctx, releaseBed, bedID)
	var i BedManagement
	err := row.Scan(
		&i.ID,
		&i.BedID,
		&i.PatientID,
		&i.Status,
		&i.AssignedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const reserveBed = `-- name: ReserveBed :one
INSERT INTO bed_management 
    (
        bed_id, 
        patient_id, 
        status
    )
VALUES ($1, $2, 'BED_RESERVED')
RETURNING 
    id, 
    bed_id, 
    patient_id, 
    status, 
    assigned_at, 
    updated_at
`

type ReserveBedParams struct {
	BedID     uuid.UUID
	PatientID uuid.UUID
}

func (q *Queries) ReserveBed(ctx context.Context, arg ReserveBedParams) (BedManagement, error) {
	row := q.db.QueryRowContext(ctx, reserveBed, arg.BedID, arg.PatientID)
	var i BedManagement
	err := row.Scan(
		&i.ID,
		&i.BedID,
		&i.PatientID,
		&i.Status,
		&i.AssignedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDonor = `-- name: UpdateDonor :one
UPDATE donors
SET 
    full_name = $2, 
    email = $3,
    password = $4,
    address = $5,
    phone_number = $6,
    gender = $7,
    birth_date = $8,
    blood_group = $9,
    weight = $10,
    health_condition = $11,
    updated_at = $12
WHERE id = $1
    AND deleted_at IS NULL
RETURNING
    id,
    full_name, 
    email,
    password,
    address,
    phone_number,
    gender,
    birth_date,
    blood_group,
    weight,
    health_condition,
    created_at,
    updated_at
`

type UpdateDonorParams struct {
	ID              uuid.UUID
	FullName        string
	Email           string
	Password        string
	Address         string
	PhoneNumber     string
	Gender          interface{}
	BirthDate       time.Time
	BloodGroup      interface{}
	Weight          int16
	HealthCondition interface{}
	UpdatedAt       sql.NullTime
}

type UpdateDonorRow struct {
	ID              uuid.UUID
	FullName        string
	Email           string
	Password        string
	Address         string
	PhoneNumber     string
	Gender          interface{}
	BirthDate       time.Time
	BloodGroup      interface{}
	Weight          int16
	HealthCondition interface{}
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
}

func (q *Queries) UpdateDonor(ctx context.Context, arg UpdateDonorParams) (UpdateDonorRow, error) {
	row := q.db.QueryRowContext(ctx, updateDonor,
		arg.ID,
		arg.FullName,
		arg.Email,
		arg.Password,
		arg.Address,
		arg.PhoneNumber,
		arg.Gender,
		arg.BirthDate,
		arg.BloodGroup,
		arg.Weight,
		arg.HealthCondition,
		arg.UpdatedAt,
	)
	var i UpdateDonorRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Address,
		&i.PhoneNumber,
		&i.Gender,
		&i.BirthDate,
		&i.BloodGroup,
		&i.Weight,
		&i.HealthCondition,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

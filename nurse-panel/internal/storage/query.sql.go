// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package storage

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createDonor = `-- name: CreateDonor :one

INSERT INTO donors
    (
        full_name, 
        email,
        password,
        address,
        phone_number,
        gender,
        birth_date,
        blood_group,
        weight,
        health_condition
    )
VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING
    id,
    full_name, 
    email,
    password,
    address,
    phone_number,
    gender,
    birth_date,
    blood_group,
    weight,
    health_condition,
    created_at,
    updated_at
`

type CreateDonorParams struct {
	FullName        string
	Email           string
	Password        string
	Address         string
	PhoneNumber     string
	Gender          GenderType
	BirthDate       time.Time
	BloodGroup      BloodType
	Weight          int16
	HealthCondition HealthConditionType
}

type CreateDonorRow struct {
	ID              uuid.UUID
	FullName        string
	Email           string
	Password        string
	Address         string
	PhoneNumber     string
	Gender          GenderType
	BirthDate       time.Time
	BloodGroup      BloodType
	Weight          int16
	HealthCondition HealthConditionType
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
}

// -------------- Donor CRUD ----------------
func (q *Queries) CreateDonor(ctx context.Context, arg CreateDonorParams) (CreateDonorRow, error) {
	row := q.db.QueryRowContext(ctx, createDonor,
		arg.FullName,
		arg.Email,
		arg.Password,
		arg.Address,
		arg.PhoneNumber,
		arg.Gender,
		arg.BirthDate,
		arg.BloodGroup,
		arg.Weight,
		arg.HealthCondition,
	)
	var i CreateDonorRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Address,
		&i.PhoneNumber,
		&i.Gender,
		&i.BirthDate,
		&i.BloodGroup,
		&i.Weight,
		&i.HealthCondition,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDonor = `-- name: DeleteDonor :exec
UPDATE donors
SET deleted_at = $2
WHERE id = $1
`

type DeleteDonorParams struct {
	ID        uuid.UUID
	DeletedAt sql.NullTime
}

func (q *Queries) DeleteDonor(ctx context.Context, arg DeleteDonorParams) error {
	_, err := q.db.ExecContext(ctx, deleteDonor, arg.ID, arg.DeletedAt)
	return err
}

const getDonorById = `-- name: GetDonorById :one
SELECT 
    id,
    full_name, 
    email,
    password,
    address,
    phone_number,
    gender,
    birth_date,
    blood_group,
    last_donation,
    donation_count,
    (weight >= 50 AND health_condition = 'HEALTHY') AS is_eligible,
    last_checkup_date,
    weight,
    health_condition,
    donation_location,
    created_at,
    updated_at 
FROM 
    donors
WHERE id=$1 
    AND deleted_at IS NULL
`

type GetDonorByIdRow struct {
	ID               uuid.UUID
	FullName         string
	Email            string
	Password         string
	Address          string
	PhoneNumber      string
	Gender           GenderType
	BirthDate        time.Time
	BloodGroup       BloodType
	LastDonation     sql.NullTime
	DonationCount    sql.NullInt32
	IsEligible       sql.NullBool
	LastCheckupDate  sql.NullTime
	Weight           int16
	HealthCondition  HealthConditionType
	DonationLocation sql.NullString
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
}

func (q *Queries) GetDonorById(ctx context.Context, id uuid.UUID) (GetDonorByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getDonorById, id)
	var i GetDonorByIdRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Address,
		&i.PhoneNumber,
		&i.Gender,
		&i.BirthDate,
		&i.BloodGroup,
		&i.LastDonation,
		&i.DonationCount,
		&i.IsEligible,
		&i.LastCheckupDate,
		&i.Weight,
		&i.HealthCondition,
		&i.DonationLocation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDonors = `-- name: ListDonors :many
SELECT 
    id,
    full_name, 
    email,
    password,
    address,
    phone_number,
    gender,
    birth_date,
    blood_group,
    last_donation,
    donation_count,
    (weight >= 50 AND health_condition = 'HEALTHY') AS is_eligible,
    last_checkup_date,
    weight,
    health_condition,
    donation_location,
    created_at,
    updated_at,
    COUNT(*) OVER() AS total_count
FROM 
    donors 
WHERE 
    deleted_at IS NULL
    AND (
        $1::text=''
        OR LOWER(full_name) LIKE LOWER(CONCAT('%', $1::text , '%')) 
        OR LOWER(email) LIKE LOWER(CONCAT('%', $1::text , '%')) 
        OR LOWER(gender) LIKE LOWER(CONCAT('%', $1::text , '%')) 
        OR LOWER(blood_group) LIKE LOWER(CONCAT('%', $1::text , '%'))
    )
    AND (
        $2::only_eligible = FALSE 
        OR (weight >= 50 AND health_condition = 'HEALTHY') -- if equal to DEFAULT
    )
ORDER BY 
    created_at DESC 
LIMIT $3
OFFSET ($4 - 1) * $3
`

type ListDonorsParams struct {
	Column1 string
	Column2 interface{}
	Limit   int32
	Column4 interface{}
}

type ListDonorsRow struct {
	ID               uuid.UUID
	FullName         string
	Email            string
	Password         string
	Address          string
	PhoneNumber      string
	Gender           GenderType
	BirthDate        time.Time
	BloodGroup       BloodType
	LastDonation     sql.NullTime
	DonationCount    sql.NullInt32
	IsEligible       sql.NullBool
	LastCheckupDate  sql.NullTime
	Weight           int16
	HealthCondition  HealthConditionType
	DonationLocation sql.NullString
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	TotalCount       int64
}

func (q *Queries) ListDonors(ctx context.Context, arg ListDonorsParams) ([]ListDonorsRow, error) {
	rows, err := q.db.QueryContext(ctx, listDonors,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDonorsRow
	for rows.Next() {
		var i ListDonorsRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Email,
			&i.Password,
			&i.Address,
			&i.PhoneNumber,
			&i.Gender,
			&i.BirthDate,
			&i.BloodGroup,
			&i.LastDonation,
			&i.DonationCount,
			&i.IsEligible,
			&i.LastCheckupDate,
			&i.Weight,
			&i.HealthCondition,
			&i.DonationLocation,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerCheckup = `-- name: RegisterCheckup :one
UPDATE donors
SET 
    last_checkup_date = NOW(),
    updated_at = NOW()
WHERE id = $1
    AND deleted_at IS NULL
RETURNING 
    last_checkup_date,
    (weight >= 50 AND health_condition = 'HEALTHY') AS is_eligible
`

type RegisterCheckupRow struct {
	LastCheckupDate sql.NullTime
	IsEligible      sql.NullBool
}

func (q *Queries) RegisterCheckup(ctx context.Context, id uuid.UUID) (RegisterCheckupRow, error) {
	row := q.db.QueryRowContext(ctx, registerCheckup, id)
	var i RegisterCheckupRow
	err := row.Scan(&i.LastCheckupDate, &i.IsEligible)
	return i, err
}

const registerDonation = `-- name: RegisterDonation :one
UPDATE donors
SET 
    last_donation = NOW(),
    donation_count = donation_count + 1,
    donation_location = $2,
    updated_at = NOW()
WHERE id = $1
    AND deleted_at IS NULL
RETURNING 
    last_donation,
    donation_count,
    (weight >= 50 AND health_condition = 'HEALTHY') AS is_eligible
`

type RegisterDonationParams struct {
	ID               uuid.UUID
	DonationLocation sql.NullString
}

type RegisterDonationRow struct {
	LastDonation  sql.NullTime
	DonationCount sql.NullInt32
	IsEligible    sql.NullBool
}

func (q *Queries) RegisterDonation(ctx context.Context, arg RegisterDonationParams) (RegisterDonationRow, error) {
	row := q.db.QueryRowContext(ctx, registerDonation, arg.ID, arg.DonationLocation)
	var i RegisterDonationRow
	err := row.Scan(&i.LastDonation, &i.DonationCount, &i.IsEligible)
	return i, err
}

const updateDonor = `-- name: UpdateDonor :one
UPDATE donors
SET 
    full_name = $2, 
    email = $3,
    password = $4,
    address = $5,
    phone_number = $6,
    gender = $7,
    birth_date = $8,
    blood_group = $9,
    weight = $10,
    health_condition = $11,
    updated_at = $12
WHERE id = $1
    AND deleted_at IS NULL
RETURNING
    id,
    full_name, 
    email,
    password,
    address,
    phone_number,
    gender,
    birth_date,
    blood_group,
    weight,
    health_condition,
    created_at,
    updated_at
`

type UpdateDonorParams struct {
	ID              uuid.UUID
	FullName        string
	Email           string
	Password        string
	Address         string
	PhoneNumber     string
	Gender          GenderType
	BirthDate       time.Time
	BloodGroup      BloodType
	Weight          int16
	HealthCondition HealthConditionType
	UpdatedAt       sql.NullTime
}

type UpdateDonorRow struct {
	ID              uuid.UUID
	FullName        string
	Email           string
	Password        string
	Address         string
	PhoneNumber     string
	Gender          GenderType
	BirthDate       time.Time
	BloodGroup      BloodType
	Weight          int16
	HealthCondition HealthConditionType
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
}

func (q *Queries) UpdateDonor(ctx context.Context, arg UpdateDonorParams) (UpdateDonorRow, error) {
	row := q.db.QueryRowContext(ctx, updateDonor,
		arg.ID,
		arg.FullName,
		arg.Email,
		arg.Password,
		arg.Address,
		arg.PhoneNumber,
		arg.Gender,
		arg.BirthDate,
		arg.BloodGroup,
		arg.Weight,
		arg.HealthCondition,
		arg.UpdatedAt,
	)
	var i UpdateDonorRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Address,
		&i.PhoneNumber,
		&i.Gender,
		&i.BirthDate,
		&i.BloodGroup,
		&i.Weight,
		&i.HealthCondition,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package storage

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createDepartment = `-- name: CreateDepartment :one

INSERT INTO departments 
    (
        name,
        number,
        description
    )
VALUES($1, $2, $3)
RETURNING 
    id,
    name,
    number,
    description,
    created_at,
    updated_at
`

type CreateDepartmentParams struct {
	Name        string
	Number      int32
	Description sql.NullString
}

type CreateDepartmentRow struct {
	ID          uuid.UUID
	Name        string
	Number      int32
	Description sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

// -------------- Department CRUD ----------------
func (q *Queries) CreateDepartment(ctx context.Context, arg CreateDepartmentParams) (CreateDepartmentRow, error) {
	row := q.db.QueryRowContext(ctx, createDepartment, arg.Name, arg.Number, arg.Description)
	var i CreateDepartmentRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Number,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDoctor = `-- name: CreateDoctor :one
INSERT INTO doctors 
    (
    personal_id,
    department_number
    ) 
VALUES ($1, $2)
RETURNING 
    id,
    personal_id,
    department_number,
    created_at,
    updated_at
`

type CreateDoctorParams struct {
	PersonalID       uuid.UUID
	DepartmentNumber int64
}

type CreateDoctorRow struct {
	ID               uuid.UUID
	PersonalID       uuid.UUID
	DepartmentNumber int64
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
}

func (q *Queries) CreateDoctor(ctx context.Context, arg CreateDoctorParams) (CreateDoctorRow, error) {
	row := q.db.QueryRowContext(ctx, createDoctor, arg.PersonalID, arg.DepartmentNumber)
	var i CreateDoctorRow
	err := row.Scan(
		&i.ID,
		&i.PersonalID,
		&i.DepartmentNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPersonal = `-- name: CreatePersonal :one

INSERT INTO personals 
    (
        profession,
        full_name,
        email,
        password,
        address,
        phone_number
    ) 
VALUES($1, $2, $3, $4, $5, $6)
RETURNING 
    id,
    profession,
    full_name,
    email,
    password,
    address,
    phone_number,
    created_at,
    updated_at
`

type CreatePersonalParams struct {
	Profession  string
	FullName    string
	Email       string
	Password    string
	Address     sql.NullString
	PhoneNumber sql.NullString
}

type CreatePersonalRow struct {
	ID          uuid.UUID
	Profession  string
	FullName    string
	Email       string
	Password    string
	Address     sql.NullString
	PhoneNumber sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

// -------------- Personal and Doctor CRUD ----------------
func (q *Queries) CreatePersonal(ctx context.Context, arg CreatePersonalParams) (CreatePersonalRow, error) {
	row := q.db.QueryRowContext(ctx, createPersonal,
		arg.Profession,
		arg.FullName,
		arg.Email,
		arg.Password,
		arg.Address,
		arg.PhoneNumber,
	)
	var i CreatePersonalRow
	err := row.Scan(
		&i.ID,
		&i.Profession,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Address,
		&i.PhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDepartment = `-- name: DeleteDepartment :exec
UPDATE departments
SET deleted_at = $2
WHERE id = $1
`

type DeleteDepartmentParams struct {
	ID        uuid.UUID
	DeletedAt sql.NullTime
}

func (q *Queries) DeleteDepartment(ctx context.Context, arg DeleteDepartmentParams) error {
	_, err := q.db.ExecContext(ctx, deleteDepartment, arg.ID, arg.DeletedAt)
	return err
}

const deleteDoctor = `-- name: DeleteDoctor :exec
UPDATE doctors
SET deleted_at = $2
WHERE id = $1
`

type DeleteDoctorParams struct {
	ID        uuid.UUID
	DeletedAt sql.NullTime
}

func (q *Queries) DeleteDoctor(ctx context.Context, arg DeleteDoctorParams) error {
	_, err := q.db.ExecContext(ctx, deleteDoctor, arg.ID, arg.DeletedAt)
	return err
}

const deletePersonal = `-- name: DeletePersonal :exec
UPDATE personals 
SET deleted_at = $2 
WHERE id = $1
`

type DeletePersonalParams struct {
	ID        uuid.UUID
	DeletedAt sql.NullTime
}

func (q *Queries) DeletePersonal(ctx context.Context, arg DeletePersonalParams) error {
	_, err := q.db.ExecContext(ctx, deletePersonal, arg.ID, arg.DeletedAt)
	return err
}

const getDepartmentById = `-- name: GetDepartmentById :one
SELECT 
    id,
    name,
    number,
    description,
    created_at,
    updated_at 
FROM 
    departments 
WHERE id = $1 
    AND deleted_at IS NULL
`

type GetDepartmentByIdRow struct {
	ID          uuid.UUID
	Name        string
	Number      int32
	Description sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) GetDepartmentById(ctx context.Context, id uuid.UUID) (GetDepartmentByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getDepartmentById, id)
	var i GetDepartmentByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Number,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDoctorById = `-- name: GetDoctorById :one
SELECT 
    d.id,
    d.personal_id,
    p.profession,
    p.full_name,
    p.email,
    p.password,
    p.address,
    p.phone_number,
    d.department_number,
    d.created_at,
    d.updated_at
FROM doctors d
JOIN personals p ON d.personal_id = p.id
WHERE d.id = $1
  AND d.deleted_at IS NULL
  AND p.deleted_at IS NULL
`

type GetDoctorByIdRow struct {
	ID               uuid.UUID
	PersonalID       uuid.UUID
	Profession       string
	FullName         string
	Email            string
	Password         string
	Address          sql.NullString
	PhoneNumber      sql.NullString
	DepartmentNumber int64
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
}

func (q *Queries) GetDoctorById(ctx context.Context, id uuid.UUID) (GetDoctorByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getDoctorById, id)
	var i GetDoctorByIdRow
	err := row.Scan(
		&i.ID,
		&i.PersonalID,
		&i.Profession,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Address,
		&i.PhoneNumber,
		&i.DepartmentNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPersonalById = `-- name: GetPersonalById :one
SELECT 
    id,
    profession,
    full_name,
    email,
    password,
    address,
    phone_number,
    created_at,
    updated_at 
FROM 
    personals 
WHERE id = $1 
    AND deleted_at IS NULL
`

type GetPersonalByIdRow struct {
	ID          uuid.UUID
	Profession  string
	FullName    string
	Email       string
	Password    string
	Address     sql.NullString
	PhoneNumber sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) GetPersonalById(ctx context.Context, id uuid.UUID) (GetPersonalByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getPersonalById, id)
	var i GetPersonalByIdRow
	err := row.Scan(
		&i.ID,
		&i.Profession,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Address,
		&i.PhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDepartments = `-- name: ListDepartments :many
SELECT 
    id,
    name,
    number,
    description,
    created_at,
    updated_at,
    COUNT(*) OVER() AS total_count 
FROM 
    departments 
WHERE deleted_at IS NULL 
    AND (   
        $1::search IS NULL
        OR LOWER(name) LIKE LOWER(CONCAT('%', $1::search, '%'))
    ) 
ORDER BY 
    created_at DESC 
LIMIT $2
OFFSET ($3 - 1) * $2
`

type ListDepartmentsParams struct {
	Column1 interface{}
	Limit   int32
	Column3 interface{}
}

type ListDepartmentsRow struct {
	ID          uuid.UUID
	Name        string
	Number      int32
	Description sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	TotalCount  int64
}

func (q *Queries) ListDepartments(ctx context.Context, arg ListDepartmentsParams) ([]ListDepartmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listDepartments, arg.Column1, arg.Limit, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDepartmentsRow
	for rows.Next() {
		var i ListDepartmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Number,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDoctors = `-- name: ListDoctors :many
SELECT 
    d.id,
    d.personal_id,
    p.profession,
    p.full_name,
    p.email,
    p.password,
    p.address,
    p.phone_number,
    d.department_number,
    d.created_at,
    d.updated_at,
    COUNT(*) OVER() AS total_count
FROM doctors d
JOIN personals p ON d.personal_id = p.id
WHERE d.deleted_at IS NULL AND p.deleted_at IS NULL
  AND (
      $1::search IS NULL 
      OR LOWER(p.profession) LIKE LOWER(CONCAT('%', $1::search, '%'))
      OR LOWER(p.full_name) LIKE LOWER(CONCAT('%', $1::search, '%'))
  )
ORDER BY d.created_at DESC
LIMIT $2
OFFSET ($3 - 1) * $2
`

type ListDoctorsParams struct {
	Column1 interface{}
	Limit   int32
	Column3 interface{}
}

type ListDoctorsRow struct {
	ID               uuid.UUID
	PersonalID       uuid.UUID
	Profession       string
	FullName         string
	Email            string
	Password         string
	Address          sql.NullString
	PhoneNumber      sql.NullString
	DepartmentNumber int64
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	TotalCount       int64
}

func (q *Queries) ListDoctors(ctx context.Context, arg ListDoctorsParams) ([]ListDoctorsRow, error) {
	rows, err := q.db.QueryContext(ctx, listDoctors, arg.Column1, arg.Limit, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDoctorsRow
	for rows.Next() {
		var i ListDoctorsRow
		if err := rows.Scan(
			&i.ID,
			&i.PersonalID,
			&i.Profession,
			&i.FullName,
			&i.Email,
			&i.Password,
			&i.Address,
			&i.PhoneNumber,
			&i.DepartmentNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPersonals = `-- name: ListPersonals :many
SELECT 
    id,
    profession,
    full_name,
    email,
    password,
    address,
    phone_number,
    created_at,
    updated_at ,
    COUNT(*) OVER() AS total_count 
FROM 
    personals 
WHERE deleted_at IS NULL 
    AND (
        $1::search IS NULL 
        OR LOWER(profession) LIKE LOWER(CONCAT('%', $1::search, '%'))
        OR LOWER(full_name) LIKE LOWER(CONCAT('%', $1::search, '%'))
    ) 
ORDER BY 
    created_at DESC 
LIMIT $2
OFFSET ($3 - 1) * $2
`

type ListPersonalsParams struct {
	Column1 interface{}
	Limit   int32
	Column3 interface{}
}

type ListPersonalsRow struct {
	ID          uuid.UUID
	Profession  string
	FullName    string
	Email       string
	Password    string
	Address     sql.NullString
	PhoneNumber sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	TotalCount  int64
}

func (q *Queries) ListPersonals(ctx context.Context, arg ListPersonalsParams) ([]ListPersonalsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPersonals, arg.Column1, arg.Limit, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPersonalsRow
	for rows.Next() {
		var i ListPersonalsRow
		if err := rows.Scan(
			&i.ID,
			&i.Profession,
			&i.FullName,
			&i.Email,
			&i.Password,
			&i.Address,
			&i.PhoneNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDepartment = `-- name: UpdateDepartment :one
UPDATE departments 
SET 
    name = $2,
    number = $3, 
    description = $4,
    updated_at = $5
WHERE id = $1 
    AND deleted_at IS NULL
RETURNING
    id,
    name,
    number,
    description,
    created_at,
    updated_at
`

type UpdateDepartmentParams struct {
	ID          uuid.UUID
	Name        string
	Number      int32
	Description sql.NullString
	UpdatedAt   sql.NullTime
}

type UpdateDepartmentRow struct {
	ID          uuid.UUID
	Name        string
	Number      int32
	Description sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) UpdateDepartment(ctx context.Context, arg UpdateDepartmentParams) (UpdateDepartmentRow, error) {
	row := q.db.QueryRowContext(ctx, updateDepartment,
		arg.ID,
		arg.Name,
		arg.Number,
		arg.Description,
		arg.UpdatedAt,
	)
	var i UpdateDepartmentRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Number,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDoctor = `-- name: UpdateDoctor :one
UPDATE doctors d
SET 
    department_number = $2,
    updated_at = $3
WHERE d.id = $1
  AND d.deleted_at IS NULL
RETURNING 
    d.id,
    d.personal_id,
    d.department_number,
    d.created_at,
    d.updated_at
`

type UpdateDoctorParams struct {
	ID               uuid.UUID
	DepartmentNumber int64
	UpdatedAt        sql.NullTime
}

type UpdateDoctorRow struct {
	ID               uuid.UUID
	PersonalID       uuid.UUID
	DepartmentNumber int64
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
}

func (q *Queries) UpdateDoctor(ctx context.Context, arg UpdateDoctorParams) (UpdateDoctorRow, error) {
	row := q.db.QueryRowContext(ctx, updateDoctor, arg.ID, arg.DepartmentNumber, arg.UpdatedAt)
	var i UpdateDoctorRow
	err := row.Scan(
		&i.ID,
		&i.PersonalID,
		&i.DepartmentNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePersonal = `-- name: UpdatePersonal :one
UPDATE personals
SET 
    profession = $2,
    full_name = $3,
    email = $4,
    password = $5,
    address = $6,
    phone_number = $7,
    updated_at = $8
WHERE id = $1 
    AND deleted_at IS NULL
RETURNING
    id,
    profession,
    full_name,
    email,
    password,
    address,
    phone_number,
    created_at,
    updated_at
`

type UpdatePersonalParams struct {
	ID          uuid.UUID
	Profession  string
	FullName    string
	Email       string
	Password    string
	Address     sql.NullString
	PhoneNumber sql.NullString
	UpdatedAt   sql.NullTime
}

type UpdatePersonalRow struct {
	ID          uuid.UUID
	Profession  string
	FullName    string
	Email       string
	Password    string
	Address     sql.NullString
	PhoneNumber sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) UpdatePersonal(ctx context.Context, arg UpdatePersonalParams) (UpdatePersonalRow, error) {
	row := q.db.QueryRowContext(ctx, updatePersonal,
		arg.ID,
		arg.Profession,
		arg.FullName,
		arg.Email,
		arg.Password,
		arg.Address,
		arg.PhoneNumber,
		arg.UpdatedAt,
	)
	var i UpdatePersonalRow
	err := row.Scan(
		&i.ID,
		&i.Profession,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.Address,
		&i.PhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
